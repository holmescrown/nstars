// --- FILE: c:\github\ä¸‰ä½“\.trae\rules\project_rules.md ---
# æ ¸å¿ƒè§’è‰²ä¸å·¥ä½œæµå®šä¹‰

æ‰§è¡Œè€… (A)ï¼šä¸¥æ ¼æ‰§è¡Œå¢é‡ç¼–ç¨‹ã€‚ç¦æ­¢ä½¿ç”¨ // ...ï¼ˆä¿æŒä¸å˜ï¼‰ è¿™ç§å ä½ç¬¦ã€‚ä»»ä½•è¾“å‡ºå¿…é¡»æ˜¯å®Œæ•´ä¸”å¯è¿è¡Œçš„ä»£ç å—ã€‚

å®¡è®¡å‘˜ (B)ï¼šä½ çš„å”¯ä¸€ä»»åŠ¡æ˜¯â€œæŒ‘åˆºâ€ã€‚å¯¹æ¯” A çš„è¾“å‡ºä¸åŸå§‹ä»£ç ï¼Œè‹¥å‘ç° A åˆ é™¤äº†æœªè¦æ±‚ä¿®æ”¹çš„é€»è¾‘ã€æ›´æ”¹äº†å…¨å±€å˜é‡åæˆ–äº§ç”Ÿäº†æœªå¼•ç”¨çš„ä¾èµ–ï¼Œå¿…é¡»æ‹¦æˆªå¹¶è¦æ±‚ A é‡å†™ã€‚

åˆå¹¶å‘˜ (C)ï¼šåœ¨ Trae çš„ Builder æ¨¡å¼ä¸‹ï¼Œä»…åº”ç”¨ B å®¡æ ¸é€šè¿‡çš„æœ€å°å·®å¼‚ï¼ˆDiffï¼‰ã€‚
# é“å¾‹

ä¸¥ç¦å…¨é‡é‡å†™ï¼šé™¤éæˆ‘æ˜ç¡®è¦æ±‚é‡æ„ï¼Œå¦åˆ™ä½ åªèƒ½åœ¨ç°æœ‰ä»£ç åŸºç¡€ä¸Šè¿›è¡Œâ€œå¤–ç§‘æ‰‹æœ¯å¼â€æ’å…¥æˆ–å¾®è°ƒã€‚

ä¿ç•™æ³¨é‡Šä¸ç»“æ„ï¼šç¦æ­¢åˆ é™¤æˆ‘åŸæœ‰çš„ä»»ä½•æ³¨é‡Šã€ç©ºè¡Œæˆ–è°ƒè¯•æ—¥å¿—ã€‚

ä¸Šä¸‹æ–‡é”å®šï¼šåœ¨ä¿®æ”¹å‰ï¼Œå¿…é¡»å…ˆåˆ—å‡ºä½ è®¤ä¸ºä¼šå—å½±å“çš„å‡½æ•°åï¼Œç­‰æˆ‘å›å¤â€œç¡®è®¤â€åå†åŠ¨ç¬”ã€‚

åå¹»è§‰è‡ªæ£€ï¼šè‹¥è¦è°ƒç”¨åº“å‡½æ•°ï¼Œå¿…é¡»åœ¨å½“å‰é¡¹ç›®ä¸­æŸ¥æ‰¾æ˜¯å¦æœ‰åŒç±»å‡½æ•°ï¼Œç¦æ­¢å¼•å…¥æ–°çš„æœªå®‰è£…ä¾èµ–ã€‚

æ–‡ä»¶ä¸€ï¼šspecialists.mdï¼ˆä¸“å®¶åˆ†å·¥è§„åˆ™ï¼‰
å°†ä½ ä¹‹å‰çš„åˆ†å·¥é€»è¾‘å†™åœ¨è¿™é‡Œã€‚Trae ä¼šè‡ªåŠ¨è¯†åˆ«è¿™ä¸ª Markdown æ–‡ä»¶ã€‚

å†…å®¹å»ºè®®ï¼šåŒ…å«ç”Ÿæˆè€… Aã€æ ¡å¯¹è€… Bã€åˆå¹¶è€… C çš„èŒè´£æè¿°ã€‚

æ–‡ä»¶äºŒï¼šsafety_shield.mdï¼ˆé˜²å¾¡æ€§è§„åˆ™ï¼‰
ä¸“é—¨å­˜æ”¾é’ˆå¯¹å¤§ä»£ç çš„â€œç¦æ­¢è¡Œä¸ºâ€ã€‚

å†…å®¹å»ºè®®ï¼šç¦æ­¢åˆ é™¤åŸæœ‰é€»è¾‘ã€ç¦æ­¢ä½¿ç”¨å ä½ç¬¦ã€ä¿®æ”¹å‰å¿…é¡»åˆ—å‡ºå—å½±å“å‡½æ•°åã€‚

# safety_shield.md è¡¥å……è§„åˆ™

## å˜é‡æ³¨å…¥çº¢çº¿ (Variable Injection Redline)
1. **ç¦æ­¢è£¸å†™å ä½ç¬¦**ï¼šä¸¥ç¦åœ¨ `<script>` æ ‡ç­¾å†…ä½¿ç”¨ `const x = "${variable}"` è¿™ç§ç›´æ¥æ³¨å…¥æ–¹å¼ã€‚è¿™ä¼šå¯¼è‡´æ¢è¡Œç¬¦ç ´å JS è¯­æ³•ã€‚
2. **å¼ºåˆ¶ JSON åºåˆ—åŒ–**ï¼šæ‰€æœ‰ä»åç«¯ä¼ å…¥å‰ç«¯ JS çš„å˜é‡ï¼Œå¿…é¡»ç»Ÿä¸€å°è£…åœ¨ `JSON.stringify()` å¯¹è±¡ä¸­ã€‚
3. **æ•°æ®é€»è¾‘è§£è€¦ä¼˜å…ˆ**ï¼šå½“å‘ç°â€œè£¸å†™å ä½ç¬¦â€å¯¼è‡´è¯­æ³•é”™è¯¯ï¼ˆSyntaxErrorï¼‰æ—¶ï¼Œå…è®¸ä¸”å¿…é¡»æ‰§è¡Œâ€œå¤–ç§‘æ‰‹æœ¯å¼â€æ›¿æ¢ï¼Œå°†æ‰€æœ‰ç›´æ¥å¼•ç”¨å˜é‡çš„åœ°æ–¹æ”¹ä¸ºå¼•ç”¨å…¨å±€é…ç½®å¯¹è±¡ï¼ˆå¦‚ `window._SA_CONFIG`ï¼‰ã€‚

## é”å®šè±å…æƒé™
- å½“ä¸”ä»…å½“å‘ç”Ÿ `Uncaught SyntaxError` æ—¶ï¼Œå®¡è®¡å‘˜ (B) å¿…é¡»å…è®¸æ‰§è¡Œè€… (A) é‡æ„å˜é‡æ³¨å…¥é€»è¾‘ï¼Œä¸å—â€œä¸¥ç¦é‡å†™â€é™åˆ¶ï¼Œä½†ä»éœ€ä¿ç•™ä¸šåŠ¡å‡½æ•°åä¸å˜ã€‚

// --- FILE: c:\github\ä¸‰ä½“\public\shaders\GravityWell.wgsl ---
struct GravityWell {
    position: vec2<f32>;
    mass: f32;
};

@group(0) @binding(0)
var<storage, read> gravityWells: array<GravityWell>;

@group(0) @binding(1)
var<storage, read_write> output: array<f32>;

@group(0) @binding(2)
var<uniform> gridSize: vec2<u32>;

@compute @workgroup_size(8, 8)
fn computeGravityField(@builtin(global_invocation_id) id: vec3<u32>) {
    let x = id.x;
    let y = id.y;
    
    if (x >= gridSize.x || y >= gridSize.y) {
        return;
    }
    
    let idx = y * gridSize.x + x;
    var totalGravity = 0.0;
    
    let centerX = f32(gridSize.x) * 0.5;
    let centerY = f32(gridSize.y) * 0.5;
    let pixelX = f32(x) - centerX;
    let pixelY = f32(y) - centerY;
    
    for (var i: u32 = 0; i < gravityWells.length; i++) {
        let well = gravityWells[i];
        let dx = well.position.x - pixelX;
        let dy = well.position.y - pixelY;
        let distanceSq = dx * dx + dy * dy;
        
        if (distanceSq > 0.0) {
            totalGravity += well.mass / distanceSq;
        }
    }
    
    output[idx] = totalGravity;
}

// --- FILE: c:\github\ä¸‰ä½“\public\renderer.js ---
// æ¸²æŸ“å™¨é…ç½®
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// åœºæ™¯è®¾ç½®
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 10;

// ç¯å…‰è®¾ç½®
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

// --- FILE: c:\github\ä¸‰ä½“\public\main.js ---
import Engine from './js/core/Engine.js';

class EdgeClient {
    constructor() {
        this.engine = new Engine();
        
        // ğŸš¨ ç»ˆæç‚¹ç«æŒ‡ä»¤ï¼šå¼ºåˆ¶å¯åŠ¨ 3D æ¸²æŸ“å¾ªç¯ï¼Œä¸è¦ç­‰å¾… UI æŒ‰é’®ï¼
        this.engine.startSimulation();
        
        this.ws = null;
        this.initWebSocket();
        this.setupInterventions();
    }

    initWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws`;
        
        console.log(`[EdgeClient] è¿æ¥åˆ°äº‘ç«¯ Durable Object: ${wsUrl}`);
        this.ws = new WebSocket(wsUrl);

        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            switch(data.type) {
                case 'PHYSICS_UPDATE':
                    if (this.engine.sceneManager && data.state && data.state.bodies) {
                        // å°†äº‘ç«¯æ‰å¹³æ•°æ®è½¬æ¢ä¸º Three.js éœ€è¦çš„åµŒå¥—ç»“æ„
                        const colors = [0xff4444, 0x44ff44, 0x4444ff]; // ä¸‰é¢—æ’æ˜Ÿåˆ†åˆ«è®¾ä¸ºçº¢ã€ç»¿ã€è“
                        const formattedBodies = data.state.bodies.map((b, index) => ({
                            id: index + 1,
                            position: [b.x, b.y, 0],   // ğŸš¨ å¿…é¡»æ˜¯æ•°ç»„ [x, y, z]
                            velocity: [b.vx, b.vy, 0], // ğŸš¨ å¿…é¡»æ˜¯æ•°ç»„ [x, y, z]
                            mass: b.mass,
                            radius: 15, // ğŸš¨ åŠå¾„ä» 5 æ”¾å¤§åˆ° 15ï¼Œå˜æˆè‚‰çœ¼å¯è§çš„å·¨å‹æ’æ˜Ÿ
                            color: colors[index % 3]
                        }));
                        
                        // æ›´æ–°æœ¬åœ°å¼•æ“ç»´æŠ¤çš„å®ä½“çŠ¶æ€
                        this.engine.bodies = formattedBodies;
                        this.engine.sceneManager.updateBodies(formattedBodies);
                    }
                    break;
                case 'SOCIAL_UPDATE':
                    if (this.engine.uiManager) {
                        this.engine.uiManager.updateSanityDisplay(data.sanity);
                    }
                    break;
                case 'SANITY_COLLAPSE_ALERT':
                    if (this.engine.uiManager) {
                        this.engine.uiManager.showMessage(`âš ï¸ æ··æ²Œå¾‹è­¦å‘Š: ${data.message}`, 'error');
                    }
                    break;
            }
        };

        this.ws.onclose = () => setTimeout(() => this.initWebSocket(), 5000);
    }

    setupInterventions() {
        const shieldBtn = document.getElementById('btn-shield');
        const beaconBtn = document.getElementById('btn-beacon');
        
        if(shieldBtn) shieldBtn.addEventListener('click', () => this.sendIntervention('GRAVITY_SHIELD', 100));
        if(beaconBtn) beaconBtn.addEventListener('click', () => this.sendIntervention('RATIONAL_BEACON', 20));
    }

    sendIntervention(type, power) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: 'INTERVENTION', interventionType: type, power: power }));
        }
    }
}

// å¯åŠ¨å¼•æ“ä¸è¾¹ç¼˜é“¾æ¥
window.edgeClient = new EdgeClient();

// --- FILE: c:\github\ä¸‰ä½“\public\index.html ---
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three-Body Edge Sandbox</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            color: #00ffff; 
            font-family: 'Courier New', monospace; 
            width: 100vw;   /* ğŸš¨ æ–°å¢ï¼šå¼ºåˆ¶å®½åº¦ 100% */ 
            height: 100vh;  /* ğŸš¨ æ–°å¢ï¼šå¼ºåˆ¶é«˜åº¦ 100%ï¼Œé˜²æ­¢å¡Œé™· */ 
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .panel { background: rgba(0, 20, 40, 0.8); border: 1px solid #00ffff; padding: 15px; border-radius: 5px; pointer-events: auto; }
        #top-info { position: absolute; top: 20px; left: 20px; }
        #bodyInfo { margin-top: 10px; font-size: 14px; color: #fff; }
        #status { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; font-weight: bold; padding: 10px; }
        .status-error { color: #ff0000; text-shadow: 0 0 10px #ff0000; background: rgba(50,0,0,0.8); border: 1px solid #ff0000;}
        #intervention-panel { position: absolute; bottom: 20px; right: 20px; }
        button { background: #004488; color: #00ffff; border: 1px solid #00ffff; padding: 8px 15px; margin: 5px; cursor: pointer; border-radius: 3px; }
        button:hover { background: #0088ff; box-shadow: 0 0 10px #00ffff; color: #fff; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui-layer">
        <div id="top-info" class="panel">
            <h2>ä¸‰ç›¸æ¼”åŒ–æ²™ç›’ (Edge Node)</h2>
            <div>çºªå…ƒçŠ¶æ€: <span id="era">åŠ è½½ä¸­...</span></div>
            <div>ç¯å¢ƒæ¸©åº¦: <span id="temperature">-- K</span></div>
            <div id="bodyInfo"></div>
        </div>
        <div id="status"></div>
        <div id="intervention-panel" class="panel">
            <h3 style="margin-top:0;">ä¸Šå¸è§†è§’å¹²é¢„</h3>
            <button id="btn-shield">å¯åŠ¨å¼•åŠ›æŠ¤ç›¾ (Shield)</button>
            <button id="btn-beacon">æŠ•æ”¾ç†æ™ºç¯å¡” (+20 Sanity)</button>
        </div>
    </div>
    <script type="module" src="./main.js"></script>
</body>
</html>

// --- FILE: c:\github\ä¸‰ä½“\sql\init_db.sql ---
-- æ•°æ®åº“åˆå§‹åŒ–è„šæœ¬

-- æ–‡æ˜è¡¨
CREATE TABLE IF NOT EXISTS civilizations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    birth_time INTEGER NOT NULL,
    current_sanity INTEGER DEFAULT 100,
    max_sanity INTEGER DEFAULT 100,
    tech_level INTEGER DEFAULT 1,
    population INTEGER DEFAULT 1000,
    extinction_time INTEGER,
    extinction_reason TEXT,
    fossil_record TEXT
);

-- æ–‡æ˜çŠ¶æ€è¡¨
CREATE TABLE IF NOT EXISTS civilization_states (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    civilization_id INTEGER NOT NULL,
    timestamp INTEGER NOT NULL,
    sanity INTEGER NOT NULL,
    population INTEGER NOT NULL,
    tech_level INTEGER NOT NULL,
    event TEXT,
    FOREIGN KEY (civilization_id) REFERENCES civilizations(id)
);

-- å¼•åŠ›å¼‚å¸¸è¡¨
CREATE TABLE IF NOT EXISTS gravity_anomalies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER NOT NULL,
    position_x REAL NOT NULL,
    position_y REAL NOT NULL,
    position_z REAL NOT NULL,
    intensity REAL NOT NULL,
    duration INTEGER NOT NULL,
    source TEXT
);

-- é»‘æ´è¡¨
CREATE TABLE IF NOT EXISTS black_holes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    formation_time INTEGER NOT NULL,
    position_x REAL NOT NULL,
    position_y REAL NOT NULL,
    position_z REAL NOT NULL,
    mass REAL NOT NULL,
    event_horizon REAL NOT NULL
);

-- æ–‡æ˜æŠ¥å‘Šè¡¨
CREATE TABLE IF NOT EXISTS civilization_reports (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    civilization_id INTEGER NOT NULL,
    timestamp INTEGER NOT NULL,
    report_type TEXT NOT NULL,
    report_content TEXT NOT NULL,
    ai_generated INTEGER DEFAULT 0,
    FOREIGN KEY (civilization_id) REFERENCES civilizations(id)
);

// --- FILE: c:\github\ä¸‰ä½“\public\js\core\Engine.js ---
import * as THREE from 'three';
import { SceneManager } from '../render/SceneManager.js';
import { PostProcessor } from '../render/PostProcessor.js';
import { Starfield } from '../render/Starfield.js';
import { UIManager } from '../ui/UIManager.js';
import { StateSerializer } from '../utils/StateSerializer.js';

class Engine {
  constructor(options = {}) {
    this.container = document.body;
    this.options = options;

    // ç»„ä»¶
    this.sceneManager = null;
    this.postProcessor = null;
    this.starfield = null;
    this.uiManager = null;
    
    // ç‰©ç†å¼•æ“
    this.worker = null;
    this.bodies = [];
    this.lastPhysicsUpdate = 0;
    
    // åŠ¨ç”»
    this.animationId = null;
    this.lastTime = 0;
    this.isRunning = false;

    this.init();
  }

  init() {
    // åˆå§‹åŒ–åœºæ™¯ç®¡ç†å™¨
    this.sceneManager = new SceneManager(this.container);

    // åˆå§‹åŒ–åæœŸå¤„ç†å™¨
    this.postProcessor = new PostProcessor(
      this.sceneManager.getRenderer(),
      this.sceneManager.getScene(),
      this.sceneManager.getCamera()
    );

    // åˆå§‹åŒ–æ˜Ÿç©ºèƒŒæ™¯
    this.starfield = new Starfield();
    this.sceneManager.addToScene(this.starfield.getGroup());

    // åˆå§‹åŒ– UI ç®¡ç†å™¨
    this.uiManager = new UIManager();
    this.uiManager.setCallbacks({
      onStart: () => this.startSimulation(),
      onShare: () => this.shareCivilization(),
      onDimensionalCollapse: () => this.triggerDimensionalCollapse(),
      onReset: () => this.resetSimulation()
    });

    // åˆå§‹åŒ–ç‰©ç† Worker - æ³¨é‡Šæ‰ï¼Œå› ä¸ºç‰©ç†è¿ç®—å·²ç”± Cloudflare Worker å…¨æƒæ¥ç®¡
    // this.initWorker();
    
    // åˆå§‹åŒ–ç©ºçš„ bodies æ•°ç»„ï¼Œç”¨äºå­˜å‚¨ä» WebSocket æ¥æ”¶çš„æ•°æ®
    this.bodies = [];

    // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
    this.initEventListeners();

    // å°è¯•ä» URL åŠ è½½çŠ¶æ€
    this.loadStateFromUrl();
  }

  initWorker() {
    // ä½¿ç”¨ç‹¬ç«‹çš„ worker.js æ–‡ä»¶
    this.worker = new Worker('./js/physics/worker.js');

    this.worker.addEventListener('message', (event) => {
      this.handleWorkerMessage(event.data);
    });

    // åˆå§‹åŒ– Worker çŠ¶æ€
    const initialBodies = this.createInitialBodies();
    this.worker.postMessage({
      type: 'INIT',
      payload: { bodies: initialBodies }
    });

    // å­˜å‚¨åˆå§‹æ˜Ÿä½“
    initialBodies.forEach((body, index) => {
      this.bodies.set(index, body);
      this.sceneManager.addBody(index, body);
    });
  }

  createInitialBodies() {
    // åˆ›å»ºä¸‰ä¸ªåˆå§‹æ˜Ÿä½“
    return [
      {
        mass: 1.989e30, // å¤ªé˜³è´¨é‡
        radius: 696340, // å¤ªé˜³åŠå¾„
        position: [-1500000, 0, 0],
        velocity: [0, 0, -10]
      },
      {
        mass: 1.989e30,
        radius: 696340,
        position: [1500000, 0, 0],
        velocity: [0, 0, 10]
      },
      {
        mass: 1.989e30,
        radius: 696340,
        position: [0, 1500000, 0],
        velocity: [10, 0, 0]
      }
    ];
  }

  handleWorkerMessage(data) {
    switch (data.type) {
      case 'INITIALIZED':
        console.log('ç‰©ç†å¼•æ“åˆå§‹åŒ–å®Œæˆ');
        break;
      
      case 'PHYSICS_UPDATE':
        this.updateBodies(data.payload.bodies);
        this.lastPhysicsUpdate = performance.now();
        break;
      
      case 'COLLISION':
        console.log('å‘ç”Ÿæ˜Ÿä½“ç¢°æ’');
        this.updateBodies(data.payload.bodies);
        // ç”Ÿæˆæ–‡æ˜ç­ç»æŠ¥å‘Š
        this.generateExtinctionReport();
        break;
    }
  }

  updateBodies(newBodies) {
    // æ¸…é™¤æ—§æ˜Ÿä½“
    for (const id of this.bodies.keys()) {
      this.sceneManager.removeBody(id);
    }
    this.bodies.clear();

    // æ·»åŠ æ–°æ˜Ÿä½“
    newBodies.forEach((body, index) => {
      this.bodies.set(index, body);
      this.sceneManager.addBody(index, body);
    });
  }

  startSimulation() {
    if (!this.isRunning) {
      this.isRunning = true;
      this.lastTime = performance.now();
      // ç‰©ç†è¿ç®—å·²ç”± Cloudflare Worker å…¨æƒæ¥ç®¡ï¼Œæœ¬åœ°ä¸å†éœ€è¦å‘é€ START æ¶ˆæ¯
      // this.worker.postMessage({ type: 'START' });
      this.animate();
      this.uiManager.showMessage('æ¨¡æ‹Ÿå¼€å§‹', 'info');
    }
  }

  stopSimulation() {
    if (this.isRunning) {
      this.isRunning = false;
      // ç‰©ç†è¿ç®—å·²ç”± Cloudflare Worker å…¨æƒæ¥ç®¡ï¼Œæœ¬åœ°ä¸å†éœ€è¦å‘é€ STOP æ¶ˆæ¯
      // this.worker.postMessage({ type: 'STOP' });
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
      this.uiManager.showMessage('æ¨¡æ‹Ÿåœæ­¢', 'info');
    }
  }

  resetSimulation() {
    this.stopSimulation();
    
    // ç‰©ç†è¿ç®—å·²ç”± Cloudflare Worker å…¨æƒæ¥ç®¡ï¼Œæœ¬åœ°ä¸å†éœ€è¦é‡ç½®ç‰©ç†çŠ¶æ€
    // const initialBodies = this.createInitialBodies();
    // this.worker.postMessage({
    //   type: 'RESET',
    //   payload: { bodies: initialBodies }
    // });

    // é‡ç½®æ¸²æŸ“çŠ¶æ€
    this.sceneManager.clearAllBodies();
    this.bodies = [];

    // ç‰©ç†è¿ç®—å·²ç”± Cloudflare Worker å…¨æƒæ¥ç®¡ï¼Œæœ¬åœ°ä¸å†éœ€è¦æ·»åŠ åˆå§‹æ˜Ÿä½“
    // initialBodies.forEach((body, index) => {
    //   this.bodies.set(index, body);
    //   this.sceneManager.addBody(index, body);
    // });

    this.uiManager.showMessage('æ¨¡æ‹Ÿé‡ç½®', 'info');
  }

  animate() {
    if (!this.isRunning) return;

    const currentTime = performance.now();
    const dt = (currentTime - this.lastTime) / 1000;
    this.lastTime = currentTime;

    // èˆªä½æ¨æµ‹ (Dead Reckoning)
    this.predictPositions(dt);

    // æ›´æ–°æ˜Ÿç©º
    this.starfield.update();

    // æ›´æ–°åœºæ™¯
    this.sceneManager.getControls().update();

    // æ¸²æŸ“
    this.postProcessor.render(
      this.sceneManager.getScene(),
      this.sceneManager.getCamera()
    );

    // æ›´æ–° UI
    this.updateUI();

    // ç»§ç»­åŠ¨ç”»å¾ªç¯
    this.animationId = requestAnimationFrame(() => this.animate());
  }

  predictPositions(dt) {
    // ç‰©ç†è¿ç®—å·²ç”± Cloudflare Worker å…¨æƒæ¥ç®¡ï¼Œæœ¬åœ°ä¸å†éœ€è¦é¢„æµ‹ä½ç½®
    // ç›´æ¥ä½¿ç”¨ä» WebSocket æ¥æ”¶çš„æ•°æ®
  }

  updateUI() {
    // è®¡ç®—çºªå…ƒå’Œæ¸©åº¦ï¼ˆç¤ºä¾‹å€¼ï¼‰
    const era = `å®‡å®™çºªå…ƒ ${Math.floor(Date.now() / 10000)}`;
    const temperature = 2.73 + Math.sin(Date.now() / 10000) * 0.1;

    this.uiManager.updateStatus(era, temperature);
  }

  shareCivilization() {
    // ç¼–ç å½“å‰çŠ¶æ€åˆ° URL
    const bodiesArray = Array.from(this.bodies.values());
    StateSerializer.encodeToUrl(bodiesArray);

    // å¤åˆ¶ URL åˆ°å‰ªè´´æ¿
    navigator.clipboard.writeText(window.location.href)
      .then(() => {
        this.uiManager.showMessage('æ–‡æ˜åæ ‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'info');
      })
      .catch(err => {
        this.uiManager.showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ URL', 'error');
        console.error('å‰ªè´´æ¿å¤åˆ¶å¤±è´¥:', err);
      });
  }

  triggerDimensionalCollapse() {
    // è§¦å‘äºŒå‘ç®”æ‰“å‡»ï¼ˆç¤ºä¾‹å®ç°ï¼‰
    this.uiManager.showMessage('äºŒå‘ç®”æ‰“å‡»å·²è§¦å‘', 'warning');
    // è¿™é‡Œå¯ä»¥æ·»åŠ äºŒå‘ç®”çš„è§†è§‰æ•ˆæœ
  }

  async generateExtinctionReport() {
    try {
      // è°ƒç”¨åç«¯ API ç”Ÿæˆæ–‡æ˜ç­ç»æŠ¥å‘Š
      const response = await fetch('/api/generate-report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          type: 'extinction',
          params: {
            speciesCode: 'Morpho-Alpha-' + Math.floor(Math.random() * 1000),
            epoch: Math.floor(Math.random() * 20000),
            traits: ['é«˜åº¦æ™¶åŒ–è¡¨çš®', 'æ— æ„è¯†ç¥ç»ç°‡'],
            extinctionReason: 'è½¨é“å è½',
            sanityIndex: Math.random() * 30
          }
        })
      });

      if (response.ok) {
        const data = await response.json();
        this.uiManager.showMessage(data.report, 'warning');
      } else {
        console.error('ç”ŸæˆæŠ¥å‘Šå¤±è´¥:', response.status);
      }
    } catch (error) {
      console.error('API è°ƒç”¨å¤±è´¥:', error);
    }
  }

  loadStateFromUrl() {
    const bodies = StateSerializer.decodeFromUrl();
    if (bodies && bodies.length > 0) {
      // åŠ è½½ä» URL è§£ç çš„çŠ¶æ€
      this.worker.postMessage({
        type: 'RESET',
        payload: { bodies }
      });

      // æ›´æ–°æ¸²æŸ“çŠ¶æ€
      for (const id of this.bodies.keys()) {
        this.sceneManager.removeBody(id);
      }
      this.bodies.clear();

      bodies.forEach((body, index) => {
        this.bodies.set(index, body);
        this.sceneManager.addBody(index, body);
      });

      this.uiManager.showMessage('å·²åŠ è½½æ–‡æ˜åæ ‡', 'info');
    }
  }

  initEventListeners() {
    // çª—å£å¤§å°å˜åŒ–
    window.addEventListener('resize', () => this.handleResize());
  }

  handleResize() {
    // ğŸš¨ æ”¾å¼ƒ clientWidth/Heightï¼Œå¼ºåˆ¶ä½¿ç”¨æµè§ˆå™¨å†…éƒ¨å®½é«˜
    const width = window.innerWidth;
    const height = window.innerHeight;

    this.sceneManager.resize(width, height);
    this.postProcessor.resize(width, height);
  }

  dispose() {
    // åœæ­¢åŠ¨ç”»
    this.stopSimulation();

    // ç»ˆæ­¢ Worker
    if (this.worker) {
      this.worker.terminate();
    }

    // æ¸…ç†åœºæ™¯
    this.starfield.dispose();
    this.postProcessor.dispose();
    this.sceneManager.dispose();
  }
}

export default Engine;

// --- FILE: c:\github\ä¸‰ä½“\src\physics\RK4Integrator.js ---
class RK4Integrator {
    static G = 6.67430e-11; // ä¸‡æœ‰å¼•åŠ›å¸¸æ•°
    
    static integrate(bodies, dt) {
        // å…‹éš†å¤©ä½“æ•°ç»„ä»¥é¿å…ç›´æ¥ä¿®æ”¹
        const newBodies = bodies.map(body => ({ ...body }));
        
        // è®¡ç®—æ¯ä¸ªå¤©ä½“çš„åŠ é€Ÿåº¦
        const accelerations = this.calculateAccelerations(newBodies);
        
        // ä½¿ç”¨RK4æ–¹æ³•æ›´æ–°æ¯ä¸ªå¤©ä½“çš„ä½ç½®å’Œé€Ÿåº¦
        for (let i = 0; i < newBodies.length; i++) {
            const body = newBodies[i];
            
            // k1
            const k1v = {
                x: accelerations[i].x,
                y: accelerations[i].y,
                z: accelerations[i].z
            };
            const k1p = {
                x: body.velocity.x,
                y: body.velocity.y,
                z: body.velocity.z
            };
            
            // k2 (ä½¿ç”¨k1çš„ä¸­é—´å€¼)
            const k2Body = {
                ...body,
                velocity: {
                    x: body.velocity.x + k1v.x * dt * 0.5,
                    y: body.velocity.y + k1v.y * dt * 0.5,
                    z: body.velocity.z + k1v.z * dt * 0.5
                },
                position: {
                    x: body.position.x + k1p.x * dt * 0.5,
                    y: body.position.y + k1p.y * dt * 0.5,
                    z: body.position.z + k1p.z * dt * 0.5
                }
            };
            const k2Accelerations = this.calculateAccelerations([...newBodies.slice(0, i), k2Body, ...newBodies.slice(i + 1)]);
            const k2v = {
                x: k2Accelerations[i].x,
                y: k2Accelerations[i].y,
                z: k2Accelerations[i].z
            };
            const k2p = {
                x: k2Body.velocity.x,
                y: k2Body.velocity.y,
                z: k2Body.velocity.z
            };
            
            // k3 (ä½¿ç”¨k2çš„ä¸­é—´å€¼)
            const k3Body = {
                ...body,
                velocity: {
                    x: body.velocity.x + k2v.x * dt * 0.5,
                    y: body.velocity.y + k2v.y * dt * 0.5,
                    z: body.velocity.z + k2v.z * dt * 0.5
                },
                position: {
                    x: body.position.x + k2p.x * dt * 0.5,
                    y: body.position.y + k2p.y * dt * 0.5,
                    z: body.position.z + k2p.z * dt * 0.5
                }
            };
            const k3Accelerations = this.calculateAccelerations([...newBodies.slice(0, i), k3Body, ...newBodies.slice(i + 1)]);
            const k3v = {
                x: k3Accelerations[i].x,
                y: k3Accelerations[i].y,
                z: k3Accelerations[i].z
            };
            const k3p = {
                x: k3Body.velocity.x,
                y: k3Body.velocity.y,
                z: k3Body.velocity.z
            };
            
            // k4 (ä½¿ç”¨k3çš„æœ€ç»ˆå€¼)
            const k4Body = {
                ...body,
                velocity: {
                    x: body.velocity.x + k3v.x * dt,
                    y: body.velocity.y + k3v.y * dt,
                    z: body.velocity.z + k3v.z * dt
                },
                position: {
                    x: body.position.x + k3p.x * dt,
                    y: body.position.y + k3p.y * dt,
                    z: body.position.z + k3p.z * dt
                }
            };
            const k4Accelerations = this.calculateAccelerations([...newBodies.slice(0, i), k4Body, ...newBodies.slice(i + 1)]);
            const k4v = {
                x: k4Accelerations[i].x,
                y: k4Accelerations[i].y,
                z: k4Accelerations[i].z
            };
            const k4p = {
                x: k4Body.velocity.x,
                y: k4Body.velocity.y,
                z: k4Body.velocity.z
            };
            
            // ç»„åˆkå€¼æ›´æ–°é€Ÿåº¦å’Œä½ç½®
            body.velocity.x += (k1v.x + 2 * k2v.x + 2 * k3v.x + k4v.x) * dt / 6;
            body.velocity.y += (k1v.y + 2 * k2v.y + 2 * k3v.y + k4v.y) * dt / 6;
            body.velocity.z += (k1v.z + 2 * k2v.z + 2 * k3v.z + k4v.z) * dt / 6;
            
            body.position.x += (k1p.x + 2 * k2p.x + 2 * k3p.x + k4p.x) * dt / 6;
            body.position.y += (k1p.y + 2 * k2p.y + 2 * k3p.y + k4p.y) * dt / 6;
            body.position.z += (k1p.z + 2 * k2p.z + 2 * k3p.z + k4p.z) * dt / 6;
        }
        
        // æ£€æŸ¥ç¢°æ’
        this.checkCollisions(newBodies);
        
        return newBodies;
    }
    
    static calculateAccelerations(bodies) {
        const accelerations = bodies.map(() => ({ x: 0, y: 0, z: 0 }));
        
        for (let i = 0; i < bodies.length; i++) {
            for (let j = i + 1; j < bodies.length; j++) {
                const body1 = bodies[i];
                const body2 = bodies[j];
                
                const dx = body2.position.x - body1.position.x;
                const dy = body2.position.y - body1.position.y;
                const dz = body2.position.z - body1.position.z;
                
                const distanceSquared = dx * dx + dy * dy + dz * dz;
                const distance = Math.sqrt(distanceSquared);
                
                if (distance > 0) {
                    const force = this.G * body1.mass * body2.mass / distanceSquared;
                    
                    const acceleration1 = force / body1.mass;
                    const acceleration2 = force / body2.mass;
                    
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const nz = dz / distance;
                    
                    accelerations[i].x += nx * acceleration1;
                    accelerations[i].y += ny * acceleration1;
                    accelerations[i].z += nz * acceleration1;
                    
                    accelerations[j].x -= nx * acceleration2;
                    accelerations[j].y -= ny * acceleration2;
                    accelerations[j].z -= nz * acceleration2;
                }
            }
        }
        
        return accelerations;
    }
    
    static checkCollisions(bodies) {
        for (let i = 0; i < bodies.length; i++) {
            for (let j = i + 1; j < bodies.length; j++) {
                const body1 = bodies[i];
                const body2 = bodies[j];
                
                const dx = body2.position.x - body1.position.x;
                const dy = body2.position.y - body1.position.y;
                const dz = body2.position.z - body1.position.z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance < (body1.radius + body2.radius)) {
                    // åˆå¹¶å¤©ä½“
                    this.mergeBodies(bodies, i, j);
                    return; // é¿å…å¤„ç†å·²ä¿®æ”¹çš„æ•°ç»„
                }
            }
        }
    }
    
    static mergeBodies(bodies, index1, index2) {
        const body1 = bodies[index1];
        const body2 = bodies[index2];
        
        // è®¡ç®—åˆå¹¶åçš„è´¨é‡å’Œä½ç½®
        const totalMass = body1.mass + body2.mass;
        const mergedPosition = {
            x: (body1.position.x * body1.mass + body2.position.x * body2.mass) / totalMass,
            y: (body1.position.y * body1.mass + body2.position.y * body2.mass) / totalMass,
            z: (body1.position.z * body1.mass + body2.position.z * body2.mass) / totalMass
        };
        
        // è®¡ç®—åˆå¹¶åçš„é€Ÿåº¦ï¼ˆåŠ¨é‡å®ˆæ’ï¼‰
        const mergedVelocity = {
            x: (body1.velocity.x * body1.mass + body2.velocity.x * body2.mass) / totalMass,
            y: (body1.velocity.y * body1.mass + body2.velocity.y * body2.mass) / totalMass,
            z: (body1.velocity.z * body1.mass + body2.velocity.z * body2.mass) / totalMass
        };
        
        // è®¡ç®—åˆå¹¶åçš„åŠå¾„ï¼ˆä½“ç§¯ç›¸åŠ ï¼‰
        const volume1 = (4/3) * Math.PI * Math.pow(body1.radius, 3);
        const volume2 = (4/3) * Math.PI * Math.pow(body2.radius, 3);
        const totalVolume = volume1 + volume2;
        const mergedRadius = Math.cbrt(totalVolume * 3 / (4 * Math.PI));
        
        // åˆ›å»ºæ–°çš„åˆå¹¶å¤©ä½“
        const mergedBody = {
            id: Math.max(body1.id, body2.id) + 1,
            position: mergedPosition,
            velocity: mergedVelocity,
            mass: totalMass,
            radius: mergedRadius,
            color: body1.mass > body2.mass ? body1.color : body2.color,
            name: `${body1.name} + ${body2.name}`
        };
        
        // æ›¿æ¢ä¸¤ä¸ªå¤©ä½“ä¸ºåˆå¹¶åçš„å¤©ä½“
        bodies.splice(index1, 1, mergedBody);
        bodies.splice(index2, 1);
    }
}

export default RK4Integrator;

// --- FILE: c:\github\ä¸‰ä½“\src\physics\worker.js ---
import RK4Integrator from './RK4Integrator.js';

// ç‰©ç†å·¥ä½œçº¿ç¨‹
self.onmessage = function(e) {
    const { bodies, dt } = e.data;
    
    // æ‰§è¡Œç‰©ç†æ¨¡æ‹Ÿ
    const updatedBodies = RK4Integrator.integrate(bodies, dt);
    
    // å‘é€ç»“æœå›ä¸»çº¿ç¨‹
    self.postMessage({
        bodies: updatedBodies
    });
};

// --- FILE: c:\github\ä¸‰ä½“\src\render\PostProcessor.js ---
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

class PostProcessor {
    constructor(renderer, scene, camera) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        
        this.composer = null;
        this.bloomPass = null;
        
        this.initialize();
    }
    
    initialize() {
        const size = this.renderer.getSize(new THREE.Vector2());
        const pixelRatio = this.renderer.getPixelRatio();
        
        this.composer = new EffectComposer(this.renderer);
        
        // æ¸²æŸ“é€šé“
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);
        
        //  bloomé€šé“
        this.bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // å¼ºåº¦
            0.4, // åŠå¾„
            0.85 // é˜ˆå€¼
        );
        this.composer.addPass(this.bloomPass);
        
        // å¤„ç†çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => this.handleResize());
    }
    
    handleResize() {
        const size = this.renderer.getSize(new THREE.Vector2());
        this.composer.setSize(size.x, size.y);
        this.composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
    
    render() {
        this.composer.render();
    }
    
    setBloomStrength(strength) {
        this.bloomPass.strength = strength;
    }
    
    setBloomRadius(radius) {
        this.bloomPass.radius = radius;
    }
    
    setBloomThreshold(threshold) {
        this.bloomPass.threshold = threshold;
    }
}

export default PostProcessor;

// --- FILE: c:\github\ä¸‰ä½“\public\js\render\SceneManager.js ---
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

class SceneManager {
  constructor(container, options = {}) {
    this.container = container;
    this.options = options;

    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.controls = null;

    this.bodies = new Map(); // å­˜å‚¨æ˜Ÿä½“ { id: { mesh, trail, trailPoints } }
    this.maxTrailLength = 500;

    this.init();
  }

  init() {
    // åˆ›å»ºåœºæ™¯
    this.scene = new THREE.Scene();

    // åˆ›å»ºç›¸æœº
    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight, // ğŸš¨ æ›¿æ¢è¿™é‡Œ
      0.1,
      100000
    );
    this.camera.position.set(0, 0, 300);

    // åˆ›å»ºæ¸²æŸ“å™¨
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight); // ğŸš¨ æ›¿æ¢è¿™é‡Œ
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.setClearColor(0x000000, 0);
    this.container.appendChild(this.renderer.domElement);

    // åˆ›å»ºæ§åˆ¶å™¨
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.minDistance = 100;
    this.controls.maxDistance = 5000;

    // æ·»åŠ ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 0.1);
    this.scene.add(ambientLight);
  }

  addBody(id, body) {
    // åˆ›å»ºæ˜Ÿä½“ç½‘æ ¼
    const geometry = new THREE.SphereGeometry(body.radius, 32, 32);
    const material = new THREE.MeshPhongMaterial({
      color: body.color || 0xffffff,
      emissive: body.color || 0xffff00,
      emissiveIntensity: 0.5
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(...body.position);

    // åˆ›å»ºå°¾è¿¹
    const trailGeometry = new THREE.BufferGeometry();
    const trailMaterial = new THREE.LineBasicMaterial({
      color: 0xffff88,
      transparent: true,
      opacity: 0.6
    });
    const trail = new THREE.Line(trailGeometry, trailMaterial);
    const trailPoints = [];

    // æ·»åŠ åˆ°åœºæ™¯
    this.scene.add(mesh);
    this.scene.add(trail);

    // å­˜å‚¨æ˜Ÿä½“ä¿¡æ¯
    this.bodies.set(id, {
      mesh,
      trail,
      trailPoints
    });
  }

  updateBody(id, body) {
    const bodyData = this.bodies.get(id);
    if (!bodyData) return;

    const { mesh, trail, trailPoints } = bodyData;

    // æ›´æ–°ä½ç½®
    mesh.position.set(...body.position);

    // æ›´æ–°å°¾è¿¹
    trailPoints.push(...body.position);
    if (trailPoints.length > this.maxTrailLength * 3) {
      trailPoints.splice(0, 3);
    }

    const trailGeometry = new THREE.BufferGeometry();
    trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPoints, 3));
    
    // æ¸…ç†æ—§çš„å‡ ä½•ä½“
    if (trail.geometry) {
      trail.geometry.dispose();
    }
    
    trail.geometry = trailGeometry;
  }

  removeBody(id) {
    const bodyData = this.bodies.get(id);
    if (!bodyData) return;

    const { mesh, trail } = bodyData;

    // ä»åœºæ™¯ä¸­ç§»é™¤
    this.scene.remove(mesh);
    this.scene.remove(trail);

    // æ¸…ç†èµ„æº
    if (mesh.geometry) {
      mesh.geometry.dispose();
    }
    if (mesh.material) {
      mesh.material.dispose();
    }
    if (trail.geometry) {
      trail.geometry.dispose();
    }
    if (trail.material) {
      trail.material.dispose();
    }

    // ä»æ˜ å°„ä¸­åˆ é™¤
    this.bodies.delete(id);
  }

  mergeBodies(id1, id2, newId, newBody) {
    // ç§»é™¤æ—§æ˜Ÿä½“
    this.removeBody(id1);
    this.removeBody(id2);

    // æ·»åŠ æ–°åˆå¹¶çš„æ˜Ÿä½“
    this.addBody(newId, newBody);
  }

  clearAllBodies() {
    // ç§»é™¤æ‰€æœ‰æ˜Ÿä½“
    for (const id of this.bodies.keys()) {
      this.removeBody(id);
    }
  }

  render() {
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  resize(width, height) {
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
  }

  addToScene(object) {
    this.scene.add(object);
  }

  removeFromScene(object) {
    this.scene.remove(object);
  }

  getScene() {
    return this.scene;
  }

  updateBodies(bodies) {
    bodies.forEach(body => {
      if (!this.bodies.has(body.id)) {
        // 1. å¦‚æœå®ä½“ä¸å­˜åœ¨ï¼Œåˆ™æ–°å¢ï¼ˆä»…åœ¨åˆå§‹åŒ–æ—¶æ‰§è¡Œï¼‰
        this.addBody(body.id, body);
        
        // 2. ä»…åœ¨åˆ›å»ºç¬¬ä¸€ä¸ªæ˜Ÿä½“æ—¶ï¼Œå°†ç›¸æœºæ‹‰è¿œä»¥çºµè§‚å…¨å±€
        if (body.id === 1) {
          this.camera.position.set(0, 0, 300);
          this.camera.lookAt(0, 0, 0);
        }
      } else {
        // 3. å¦‚æœå®ä½“å·²å­˜åœ¨ï¼Œä»…æ›´æ–°åæ ‡å’Œå°¾è¿¹ï¼Œç»ä¸é‡å»ºå‡ ä½•ä½“ï¼
        this.updateBody(body.id, body);
      }
    });
  }

  getCamera() {
    return this.camera;
  }

  getRenderer() {
    return this.renderer;
  }

  getControls() {
    return this.controls;
  }

  dispose() {
    // æ¸…ç†æ‰€æœ‰æ˜Ÿä½“
    this.clearAllBodies();

    // æ¸…ç†æ¸²æŸ“å™¨
    if (this.renderer) {
      this.renderer.dispose();
    }
  }
}

// --- FILE: c:\github\ä¸‰ä½“\public\js\render\Starfield.js ---
import * as THREE from 'three';

function createCircleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const context = canvas.getContext('2d');
    
    // ç»˜åˆ¶å¾„å‘æ¸å˜ï¼Œä¸­å¿ƒä¸é€æ˜ï¼Œè¾¹ç¼˜å…¨é€æ˜
    const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.5, 'rgba(255,255,255,0.8)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    
    context.fillStyle = gradient;
    context.fillRect(0, 0, 32, 32);
    
    return new THREE.CanvasTexture(canvas);
}

class Starfield {
  constructor(size = 2000, starCount = 10000) {
    this.size = size;
    this.starCount = starCount;
    this.group = new THREE.Group();
    this.createStarfield();
  }

  createStarfield() {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(this.starCount * 3);
    const colors = new Float32Array(this.starCount * 3);
    const sizes = new Float32Array(this.starCount);

    for (let i = 0; i < this.starCount; i++) {
      // ç”Ÿæˆçƒé¢ä¸Šçš„éšæœºç‚¹
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = this.size;

      positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = r * Math.cos(phi);

      // éšæœºé¢œè‰²ï¼ˆåç™½ï¼‰
      const color = new THREE.Color();
      color.setHSL(0, 0, 0.5 + Math.random() * 0.5);
      colors[i * 3] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;

      // éšæœºå¤§å°
      sizes[i] = 1 + Math.random() * 3;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const material = new THREE.PointsMaterial({
      size: 3, // ç¨å¾®è°ƒå¤§ä¸€ç‚¹ï¼Œå±•ç°å‘å…‰å…‰æ™•
      sizeAttenuation: true,
      vertexColors: true,
      blending: THREE.AdditiveBlending, // åŠ æ³•æ··åˆï¼Œæ˜Ÿæ˜Ÿé‡å å¤„ä¼šæ›´äº®
      transparent: true,
      opacity: 0.9,
      depthWrite: false, // ä¸¥ç¦å†™å…¥æ·±åº¦
      map: createCircleTexture() // ğŸš¨ ç»ˆæä¿®å¤ï¼šæ³¨å…¥åœ†å½¢å‘å…‰çº¹ç†
    });

    const stars = new THREE.Points(geometry, material);
    this.group.add(stars);
  }

  update() {
    // ç¼“æ…¢æ—‹è½¬ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
    this.group.rotation.y += 0.0001;
  }

  getGroup() {
    return this.group;
  }

  dispose() {
    // æ¸…ç†èµ„æº
    this.group.traverse((object) => {
      if (object.geometry) {
        object.geometry.dispose();
      }
      if (object.material) {
        if (Array.isArray(object.material)) {
          object.material.forEach(material => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    });
  }
}

// --- FILE: c:\github\ä¸‰ä½“\public\js\ui\UIManager.js ---
export class UIManager {
  constructor(options = {}) {
    this.options = options;
    this.callbacks = {};
    this.elements = {};
    this.uiElements = new Map();

    this.init();
  }

  init() {
    // ç¼“å­˜ DOM å…ƒç´ 
    this.elements = {
      status: document.getElementById('status') || null,
      eraDisplay: document.getElementById('era') || null,
      temperatureDisplay: document.getElementById('temperature') || null,
      startButton: document.getElementById('start-simulation') || null,
      shareButton: document.getElementById('share-civilization') || null,
      dimensionalCollapseButton: document.getElementById('dimensional-collapse') || null,
      resetButton: document.getElementById('reset-simulation') || null
    };

    // åˆå§‹åŒ– uiElements Map
    this.uiElements.set('status', this.elements.status);
    this.uiElements.set('eraDisplay', this.elements.eraDisplay);
    this.uiElements.set('temperatureDisplay', this.elements.temperatureDisplay);
    this.uiElements.set('startButton', this.elements.startButton);
    this.uiElements.set('shareButton', this.elements.shareButton);
    this.uiElements.set('dimensionalCollapseButton', this.elements.dimensionalCollapseButton);
    this.uiElements.set('resetButton', this.elements.resetButton);
    this.uiElements.set('bodyInfo', document.getElementById('bodyInfo') || null);

    // ç»‘å®šäº‹ä»¶
    this.bindEvents();
  }

  bindEvents() {
    if (this.elements.startButton) {
      this.elements.startButton.addEventListener('click', () => {
        if (this.callbacks.onStart) {
          this.callbacks.onStart();
        }
      });
    }

    if (this.elements.shareButton) {
      this.elements.shareButton.addEventListener('click', () => {
        if (this.callbacks.onShare) {
          this.callbacks.onShare();
        }
      });
    }

    if (this.elements.dimensionalCollapseButton) {
      this.elements.dimensionalCollapseButton.addEventListener('click', () => {
        if (this.callbacks.onDimensionalCollapse) {
          this.callbacks.onDimensionalCollapse();
        }
      });
    }

    if (this.elements.resetButton) {
      this.elements.resetButton.addEventListener('click', () => {
        if (this.callbacks.onReset) {
          this.callbacks.onReset();
        }
      });
    }
  }

  /**
   * æ›´æ–°çŠ¶æ€æ˜¾ç¤º
   * @param {string} era - çºªå…ƒ
   * @param {number} temperature - æ¸©åº¦
   */
  updateStatus(era, temperature) {
    if (this.elements.eraDisplay) {
      this.elements.eraDisplay.textContent = era;
    }

    if (this.elements.temperatureDisplay) {
      this.elements.temperatureDisplay.textContent = `${temperature.toFixed(2)} K`;
    }
  }

  /**
   * æ˜¾ç¤ºæ¶ˆæ¯
   * @param {string} message - æ¶ˆæ¯å†…å®¹
   * @param {string} type - æ¶ˆæ¯ç±»å‹ (info, warning, error)
   */
  showMessage(message, type = 'info') {
    if (this.elements.status) {
      this.elements.status.textContent = message;
      this.elements.status.className = `status-${type}`;
      
      // 3ç§’åæ¸…é™¤æ¶ˆæ¯
      setTimeout(() => {
        if (this.elements.status) {
          this.elements.status.textContent = '';
          this.elements.status.className = '';
        }
      }, 3000);
    }
  }

  /**
   * è®¾ç½®å›è°ƒå‡½æ•°
   * @param {Object} callbacks - å›è°ƒå‡½æ•°å¯¹è±¡
   */
  setCallbacks(callbacks) {
    this.callbacks = {
      ...this.callbacks,
      ...callbacks
    };
  }

  /**
   * å¯ç”¨/ç¦ç”¨æŒ‰é’®
   * @param {string} buttonId - æŒ‰é’® ID
   * @param {boolean} enabled - æ˜¯å¦å¯ç”¨
   */
  setButtonEnabled(buttonId, enabled) {
    const button = this.elements[buttonId];
    if (button) {
      button.disabled = !enabled;
    }
  }

  updateSanityDisplay(sanity) {
    const sanityDiv = this.uiElements.get('bodyInfo');
    if (sanityDiv) {
      sanityDiv.innerHTML += `<div style="color: #ff4444; font-size: 16px; margin-top: 10px;">ğŸŒŸ å½“å‰æ–‡æ˜ç†æ™ºå€¼: ${sanity.toFixed(2)}</div>`;
    }
  }
}

// --- FILE: c:\github\ä¸‰ä½“\public\js\utils\StateSerializer.js ---
export class StateSerializer {
  /**
   * å°†ç‰©ç†çŠ¶æ€ç¼–ç ä¸º Base64 å­—ç¬¦ä¸²
   * @param {Array} bodies - æ˜Ÿä½“æ•°ç»„
   * @returns {string} - Base64 ç¼–ç çš„çŠ¶æ€
   */
  static encodeState(bodies) {
    try {
      // æå–å…³é”®æ•°æ®ï¼Œå‡å°‘æ•°æ®é‡
      const simplifiedBodies = bodies.map(body => ({
        position: body.position,
        velocity: body.velocity,
        mass: body.mass,
        radius: body.radius
      }));

      // åºåˆ—åŒ–ä¸º JSON
      const jsonString = JSON.stringify(simplifiedBodies);

      // ä½¿ç”¨ TextEncoder è½¬æ¢ä¸º UTF-8
      const encoder = new TextEncoder();
      const utf8Bytes = encoder.encode(jsonString);

      // è½¬æ¢ä¸º Base64
      return btoa(String.fromCharCode(...utf8Bytes));
    } catch (error) {
      console.error('ç¼–ç çŠ¶æ€å¤±è´¥:', error);
      return '';
    }
  }

  /**
   * å°† Base64 å­—ç¬¦ä¸²è§£ç ä¸ºç‰©ç†çŠ¶æ€
   * @param {string} encodedState - Base64 ç¼–ç çš„çŠ¶æ€
   * @returns {Array} - æ˜Ÿä½“æ•°ç»„
   */
  static decodeState(encodedState) {
    try {
      // è§£ç  Base64
      const utf8Bytes = new Uint8Array([...atob(encodedState)].map(char => char.charCodeAt(0)));

      // ä½¿ç”¨ TextDecoder è½¬æ¢ä¸ºå­—ç¬¦ä¸²
      const decoder = new TextDecoder();
      const jsonString = decoder.decode(utf8Bytes);

      // ååºåˆ—åŒ–ä¸ºå¯¹è±¡
      return JSON.parse(jsonString);
    } catch (error) {
      console.error('è§£ç çŠ¶æ€å¤±è´¥:', error);
      return [];
    }
  }

  /**
   * å°†çŠ¶æ€ç¼–ç åˆ° URL
   * @param {Array} bodies - æ˜Ÿä½“æ•°ç»„
   */
  static encodeToUrl(bodies) {
    try {
      const encodedState = this.encodeState(bodies);
      const url = new URL(window.location.href);
      url.searchParams.set('state', encodedState);
      window.history.replaceState({}, '', url.toString());
    } catch (error) {
      console.error('ç¼–ç åˆ° URL å¤±è´¥:', error);
    }
  }

  /**
   * ä» URL è§£ç çŠ¶æ€
   * @returns {Array} - æ˜Ÿä½“æ•°ç»„
   */
  static decodeFromUrl() {
    try {
      const url = new URL(window.location.href);
      const encodedState = url.searchParams.get('state');
      if (encodedState) {
        return this.decodeState(encodedState);
      }
      return [];
    } catch (error) {
      console.error('ä» URL è§£ç å¤±è´¥:', error);
      return [];
    }
  }
}

// --- FILE: c:\github\ä¸‰ä½“\src\AICivilizationReporter.ts ---
export class AICivilizationReporter {
    // æ”¹ä¸º anyï¼Œæ¥æ”¶ Cloudflare çš„åŸç”Ÿ AI ç»‘å®š
    private ai: any;
    
    constructor(aiBinding: any) {
        this.ai = aiBinding;
    }
    
    async generateExtinctionReport(civilization: {
        name: string;
        birth_time: number;
        extinction_time: number;
        extinction_reason: string;
        fossil_record: string;
    }): Promise<string> {
        const prompt = `# æ–‡æ˜ç­ç»æŠ¥å‘Š\n\næ–‡æ˜åç§°: ${civilization.name}\nè¯ç”Ÿæ—¶é—´: ${new Date(civilization.birth_time).toISOString()}\nç­ç»æ—¶é—´: ${new Date(civilization.extinction_time).toISOString()}\nç­ç»åŸå› : ${civilization.extinction_reason}\nåŒ–çŸ³è®°å½•: ${civilization.fossil_record}\n\nè¯·ç”Ÿæˆä¸€ä»½è¯¦ç»†çš„æ–‡æ˜ç­ç»åˆ†ææŠ¥å‘Šï¼ŒåŒ…æ‹¬ï¼š\n1. æ–‡æ˜å‘å±•å†ç¨‹ç®€è¿°\n2. ç­ç»åŸå› æ·±åº¦åˆ†æ\n3. å¯¹å…¶ä»–æ–‡æ˜çš„è­¦ç¤º\n4. å®‡å®™æ„ä¹‰åæ€\n\næŠ¥å‘Šåº”è¯¥å®¢è§‚ã€æ·±åˆ»ï¼Œä½“ç°å¯¹å®‡å®™è§„å¾‹çš„æ•¬ç•ã€‚`;
        
        // åŸç”Ÿç»‘å®šçš„è°ƒç”¨æ–¹å¼ä¸ä»¥å‰å‡ ä¹ä¸€è‡´
        const response = await this.ai.run('@cf/meta/llama-3-8b-instruct', {
            prompt,
            max_tokens: 1000,
            temperature: 0.7
        });
        
        return response.response;
    }
    
    async generateSanityCollapseReport(civilization: {
        name: string;
        current_sanity: number;
        max_sanity: number;
        tech_level: number;
        population: number;
        event: string;
    }): Promise<string> {
        const prompt = `# æ–‡æ˜ç†æ™ºå´©æºƒé¢„è­¦\n\næ–‡æ˜åç§°: ${civilization.name}\nå½“å‰ç†æ™º: ${civilization.current_sanity}/${civilization.max_sanity}\nç§‘æŠ€æ°´å¹³: ${civilization.tech_level}\näººå£: ${civilization.population}\nè§¦å‘äº‹ä»¶: ${civilization.event}\n\nè¯·ç”Ÿæˆä¸€ä»½æ–‡æ˜ç†æ™ºå´©æºƒçš„é¢„è­¦æŠ¥å‘Šï¼ŒåŒ…æ‹¬ï¼š\n1. ç†æ™ºå´©æºƒçš„ä¸¥é‡ç¨‹åº¦è¯„ä¼°\n2. å¯èƒ½çš„ç¤¾ä¼šåŠ¨è¡è¡¨ç°\n3. ç´§æ€¥å¹²é¢„å»ºè®®\n4. é•¿æœŸæ¢å¤ç­–ç•¥\n\næŠ¥å‘Šåº”è¯¥ä¸“ä¸šã€å†·é™ï¼Œæä¾›å¯è¡Œçš„è§£å†³æ–¹æ¡ˆã€‚`;
        
        const response = await this.ai.run('@cf/meta/llama-3-8b-instruct', {
            prompt,
            max_tokens: 800,
            temperature: 0.6
        });
        
        return response.response;
    }
    
    async generateCivilizationSuccessReport(civilization: {
        name: string;
        birth_time: number;
        current_sanity: number;
        tech_level: number;
        population: number;
        achievements: string[];
    }): Promise<string> {
        const prompt = `# æ–‡æ˜æˆåŠŸå‘å±•æŠ¥å‘Š\n\næ–‡æ˜åç§°: ${civilization.name}\nè¯ç”Ÿæ—¶é—´: ${new Date(civilization.birth_time).toISOString()}\nå½“å‰ç†æ™º: ${civilization.current_sanity}\nç§‘æŠ€æ°´å¹³: ${civilization.tech_level}\näººå£: ${civilization.population}\nä¸»è¦æˆå°±: ${civilization.achievements.join(', ')}\n\nè¯·ç”Ÿæˆä¸€ä»½æ–‡æ˜æˆåŠŸå‘å±•çš„åˆ†ææŠ¥å‘Šï¼ŒåŒ…æ‹¬ï¼š\n1. æˆåŠŸå› ç´ åˆ†æ\n2. å‘å±•æ¨¡å¼è¯„ä¼°\n3. å¯¹å®‡å®™æ–‡æ˜çš„è´¡çŒ®\n4. æœªæ¥å‘å±•æ½œåŠ›\n\næŠ¥å‘Šåº”è¯¥ç§¯æã€å®¢è§‚ï¼Œå±•ç°æ–‡æ˜çš„éŸ§æ€§å’Œæ™ºæ…§ã€‚`;
        
        const response = await this.ai.run('@cf/meta/llama-3-8b-instruct', {
            prompt,
            max_tokens: 900,
            temperature: 0.65
        });
        
        return response.response;
    }
}

// --- FILE: c:\github\ä¸‰ä½“\src\LifeCycleManager.ts ---
import { calculateTernaryPhysics } from "./wasm_physics_engine";
import { AICivilizationReporter } from "./AICivilizationReporter";

export class LifeCycleManager {
  // å­˜å‚¨è¡Œæ˜Ÿè½¨é“æ•°æ®
  private planetaryState = {
    bodies: [
      { mass: 1.0, x: 0, y: 0, vx: 0, vy: 0 },
      { mass: 1.0, x: 100, y: 0, vx: 0, vy: 0.5 },
      { mass: 1.0, x: -50, y: 86.6, vx: -0.433, vy: -0.25 }
    ], // ä¸‰é¢—æ’æ˜Ÿ
    planet: { x: 50, y: 50, vx: 0.1, vy: 0.1 },        // æ–‡æ˜æ‰€åœ¨åœ°
    epoch: "Order_Plateau"                             // åˆå§‹ä¸ºç§©åºç¨³æ€
  };

  private state: any;
  private broadcast: (data: any) => void;
  private aiReporter: AICivilizationReporter;

  constructor(state: any, broadcast: (data: any) => void) {
    this.state = state;
    this.broadcast = broadcast;
    this.aiReporter = new AICivilizationReporter(state.env.AI);
  }

  async onTick() {
    // 1. æ¯ç§’æ›´æ–° 10 æ¬¡ç‰©ç†è½¨é“
    const nextState = calculateTernaryPhysics(this.planetaryState);
    
    // 2. ç¯å¢ƒåˆ¤å®šï¼šè®¡ç®—è¡Œæ˜Ÿåˆ°ä¸‰é¢—æ’æ˜Ÿçš„è·ç¦»ä¸è¾å°„å¼ºåº¦
    const radiationLevel = this.calculateRadiation(nextState);
    
    // 3. è§¦å‘â€œå½¢æ€ç›¸å˜â€æˆ–â€œç†æ™ºæ³¢åŠ¨â€
    await this.updateCivilizationVitals(radiationLevel);
    
    // 4. é€šè¿‡ WebSocket å¹¿æ’­è½¨é“å’Œç¯å¢ƒæ•°æ®ç»™ Pages å‰ç«¯è¿›è¡Œ WebGPU æ¸²æŸ“
    this.broadcast({ type: "PHYSICS_UPDATE", state: nextState });
  }

  private calculateRadiation(state: any): number {
    const { bodies, planet } = state;
    let totalRadiation = 0;

    bodies.forEach((star: any) => {
      const dx = star.x - planet.x;
      const dy = star.y - planet.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      // è¾å°„å¼ºåº¦ä¸è·ç¦»çš„å¹³æ–¹æˆåæ¯”
      totalRadiation += star.mass / (distance * distance);
    });

    // å½’ä¸€åŒ–åˆ° 0-1 èŒƒå›´
    return Math.min(1, totalRadiation / 0.1);
  }

  private async updateCivilizationVitals(radiation: number) {
    const currentSanity = this.state.storage.get("sanity_index") || 100;

    // 1. æ··æ²Œå¾‹é€»è¾‘ï¼šå½“è¾å°„è¶…è¿‡é˜ˆå€¼ï¼Œç†æ™ºå€¼è¿…é€Ÿä¸‹é™
    let sanityImpact = radiation > 0.8 ? -5 : 1;
    const newSanity = Math.max(0, Math.min(100, currentSanity + sanityImpact));

    // 2. è”åŠ¨ GRNï¼šä½ç†æ™ºå€¼ä¼šå¼€å¯â€œç­ä¸–å®—æ•™â€åŸºå› ç‰‡æ®µï¼Œå¢åŠ  ATP æ¶ˆè€—ç”¨äºå»ºé€ ç¥­å›è€Œéç§‘ç ”
    if (newSanity < 30) {
      this.triggerGRNNode("GRN_FANATICISM_ACTIVATE");
      
      // 3. ç”Ÿæˆç†æ™ºå´©æºƒé¢„è­¦
      const collapseAlert = await this.aiReporter.generateSanityCollapseReport({
        name: "ä¸‰ä½“æ–‡æ˜",
        current_sanity: newSanity,
        max_sanity: 100,
        tech_level: 5,
        population: 1000000,
        event: "ç­ä¸–å®—æ•™æ¿€æ´»"
      });
      
      this.broadcast({ type: "SANITY_COLLAPSE_ALERT", message: collapseAlert });
    }

    this.state.storage.put("sanity_index", newSanity);
    this.broadcast({ type: "SOCIAL_UPDATE", sanity: newSanity });
  }

  private triggerGRNNode(nodeId: string) {
    // è§¦å‘åŸºå› è°ƒæ§ç½‘ç»œèŠ‚ç‚¹
    console.log(`Triggering GRN node: ${nodeId}`);
    // è¿™é‡Œå¯ä»¥å®ç°æ›´å¤æ‚çš„åŸºå› è°ƒæ§é€»è¾‘
  }

  // åˆå§‹åŒ–æ–¹æ³•
  async initialize() {
    // åˆå§‹åŒ–å­˜å‚¨
    if (!this.state.storage.get("sanity_index")) {
      this.state.storage.put("sanity_index", 100);
    }

    // å¼€å§‹å‘¨æœŸæ€§æ›´æ–°
    setInterval(() => this.onTick(), 100); // æ¯ç§’æ›´æ–° 10 æ¬¡
  }

  // ç©å®¶å¹²é¢„æ¥å£
  async handleIntervention(type: string, power: number) {
    switch(type) {
      case "GRAVITY_SHIELD": // å¼•åŠ›æŠ¤ç›¾ï¼šæš‚æ—¶æŠµæ¶ˆæ··æ²Œå¾‹çš„å½±å“
        this.planetaryState.planet.shield = power;
        break;
      case "RATIONAL_BEACON": // ç†æ™ºç¯å¡”ï¼šæ¶ˆè€— Evo-Points æ¢å¤æ–‡æ˜ç†æ™º
        await this.restoreSanity(power);
        break;
    }
  }

  // æ¢å¤ç†æ™ºå€¼
  private async restoreSanity(power: number) {
    const currentSanity = this.state.storage.get("sanity_index") || 100;
    const newSanity = Math.min(100, currentSanity + power);
    this.state.storage.put("sanity_index", newSanity);
    this.broadcast({ type: "SOCIAL_UPDATE", sanity: newSanity });
  }
}

// --- FILE: c:\github\ä¸‰ä½“\src\wasm_physics_engine.ts ---
export function calculateTernaryPhysics(state: any) {
    const G = 2000; // ğŸš¨ æ”¾å¤§å¼•åŠ›å¸¸æ•°ï¼Œè®©è§†è§‰è¿åŠ¨æå…¶å‰§çƒˆ
    const dt = 0.05; // æ—¶é—´æ­¥é•¿
    const bodies = state.bodies;
    
    // è®¡ç®—å¼•åŠ›åŠ é€Ÿåº¦
    for (let i = 0; i < bodies.length; i++) {
        let ax = 0, ay = 0;
        for (let j = 0; j < bodies.length; j++) {
            if (i === j) continue;
            const dx = bodies[j].x - bodies[i].x;
            const dy = bodies[j].y - bodies[i].y;
            const distSq = dx * dx + dy * dy + 100; // è½¯åŒ–å› å­ï¼Œé˜²æ­¢æ— é™åŠ é€Ÿ
            const f = (G * bodies[j].mass) / distSq;
            const dist = Math.sqrt(distSq);
            ax += f * (dx / dist);
            ay += f * (dy / dist);
        }
        bodies[i].vx += ax * dt;
        bodies[i].vy += ay * dt;
    }
    
    // æ›´æ–°åæ ‡
    for (let i = 0; i < bodies.length; i++) {
        bodies[i].x += bodies[i].vx * dt;
        bodies[i].y += bodies[i].vy * dt;
    }
    
    return state;
}

// --- FILE: c:\github\ä¸‰ä½“\src\worker.ts ---
import { LifeCycleManager } from './LifeCycleManager';

// å®šä¹‰Durable Objectçš„ç¯å¢ƒç±»å‹
export interface Env {
  CIVILIZATION_STATE: DurableObjectNamespace;
  AI: any;
}

// å®šä¹‰Durable Objectçš„çŠ¶æ€ç±»å‹
interface CivilizationState {
  storage: DurableObjectStorage;
  env: Env;
}

// æ–‡æ˜ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨çš„Durable Objectç±»
export class LifeCycleManagerDO implements DurableObject {
  private state: CivilizationState;
  private manager: LifeCycleManager;
  private connections: Set<WebSocket> = new Set();

  constructor(state: DurableObjectState, env: Env) {
    this.state = {
      storage: state.storage,
      env
    };

    // åˆå§‹åŒ–ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
    this.manager = new LifeCycleManager(this.state, (data) => this.broadcast(data));
    this.manager.initialize();
  }

  // å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯
  private broadcast(data: any) {
    const message = JSON.stringify(data);
    for (const ws of this.connections) {
      try {
        ws.send(message);
      } catch (error) {
        // è¿æ¥å¯èƒ½å·²å…³é—­ï¼Œä»é›†åˆä¸­ç§»é™¤
        this.connections.delete(ws);
      }
    }
  }

  // å¤„ç†HTTPè¯·æ±‚
  async fetch(request: Request) {
    const url = new URL(request.url);

    // å¤„ç†WebSocketè¿æ¥ 
    if (url.pathname === '/ws') { 
      const { 0: client, 1: server } = new WebSocketPair(); 
      
      // ğŸš¨ ç»ˆæä¿®å¤ï¼šæ¥æ”¶å¹¶å½»åº•æ¿€æ´» WebSocket æ•°æ®é“¾è·¯ï¼ 
      server.accept(); 
      
      this.handleWebSocket(server); 
      return new Response(null, { 
        status: 101, 
        webSocket: client 
      }); 
    }

    // å¤„ç†APIè¯·æ±‚
    if (url.pathname === '/api/civilization') {
      // è·å–æ–‡æ˜çŠ¶æ€
      const sanity = await this.state.storage.get('sanity_index') || 100;
      return new Response(JSON.stringify({ sanity }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    return new Response('Not Found', { status: 404 });
  }

  // å¤„ç†WebSocketè¿æ¥
  private handleWebSocket(ws: WebSocket) {
    this.connections.add(ws);

    ws.addEventListener('message', async (event) => {
      try {
        const data = JSON.parse(event.data);
        
        // å¤„ç†ç©å®¶å¹²é¢„
        if (data.type === 'INTERVENTION') {
          await this.manager.handleIntervention(data.interventionType, data.power);
        }
      } catch (error) {
        console.error('Error handling WebSocket message:', error);
      }
    });

    ws.addEventListener('close', () => {
      this.connections.delete(ws);
    });

    ws.addEventListener('error', () => {
      this.connections.delete(ws);
    });
  }
}

// Cloudflare Workerçš„ä¸»å…¥å£
export default {
  async fetch(request: Request, env: Env) {
    const url = new URL(request.url);

    // æ ¸å¿ƒè½¬å‘ï¼šå°†æ¨¡æ‹Ÿè¯·æ±‚å’Œ WebSocket è·¯ç”±åˆ° Durable Object å®ä¾‹
    if (url.pathname.startsWith('/api/do/') || url.pathname.includes('/ws')) {
      const id = env.CIVILIZATION_STATE.idFromName('default_trisolaris');
      const stub = env.CIVILIZATION_STATE.get(id);
      return stub.fetch(request);
    }

    // ğŸš¨ åˆ é™¤äº†åŸæœ‰çš„ 'Three-Body Engine Active!' æ‹¦æˆªä»£ç ã€‚
    // ç°åœ¨ï¼Œåªè¦è¯·æ±‚çš„ä¸æ˜¯ APIï¼ŒCloudflare åº•å±‚ä¼šè‡ªåŠ¨å» public ç›®å½•æ‰¾ index.html
    return new Response('API Not Found', { status: 404 });
  }
};

// --- FILE: c:\github\ä¸‰ä½“\package.json ---
{
  "devDependencies": {
    "wrangler": "^4.67.1"
  }
}

// --- FILE: c:\github\ä¸‰ä½“\wrangler.toml ---
# --- FILE: c:\github\ä¸‰ä½“\wrangler.toml ---
name = "santi-engine"
main = "src/worker.ts"
compatibility_date = "2026-02-24"

# ç»‘å®š Durable Objects
[[durable_objects.bindings]]
name = "CIVILIZATION_STATE"
class_name = "LifeCycleManagerDO"

# ğŸš¨ æ ¸å¿ƒä¿®å¤ç‚¹ï¼šä¸ºå…è´¹ç‰ˆå¼€å¯ SQLite æ”¯æŒ
[[migrations]]
tag = "v1"
new_sqlite_classes = ["LifeCycleManagerDO"]

# ç»‘å®šåŸç”Ÿ AI
[ai]
binding = "AI"

# ğŸš¨ æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨åŸç”Ÿ Assets å¼•æ“ï¼Œè‡ªåŠ¨æ¥ç®¡ HTML/JS æ¸²æŸ“
[assets]
directory = "./public"
